\documentclass{article}

\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{relsize} 
\usepackage{bm} 
\usepackage{IEEEtrantools}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{cases}
\usepackage{xfrac}
\usepackage{comment}
\usepackage{framed}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{cite}
\usepackage[]{algorithm2e}
\usepackage[procnames]{listings}
\usepackage{color}
\usepackage[normalem]{ulem}

\definecolor{keywords}{RGB}{255,0,90}
\definecolor{comments}{RGB}{0,0,113}
\definecolor{red}{RGB}{160,0,0}
\definecolor{green}{RGB}{0,150,0}
 
\newcommand\pythonstyle{\lstset{language=Python, 
        basicstyle=\ttfamily\small, 
        keywordstyle=\color{keywords},
        commentstyle=\color{comments},
        stringstyle=\color{red},
        showstringspaces=false,
        identifierstyle=\color{green},
        procnamekeys={def,class}}}

\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

\oddsidemargin = 20pt
\textwidth = 420pt

\hypersetup{
     colorlinks   = true,
     linkcolor    = blue
}

\title{Project in Adaptive Control and Real Time Systems}

\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage

\section{Introduction}
\section{Dynamics}
In this project, we consider the non-linear quadcopter equations as derived by Lukkonen et al. ~\cite{luukkonen2011modelling}. A brief description of the dynamics is given to define terms which will be used in the control scheme. Let
\begin{equation}
\boldsymbol{\xi} = \begin{bmatrix}x\\y\\z\end{bmatrix},\quad
\boldsymbol{\eta}= \begin{bmatrix}\phi\\\theta\\\psi\end{bmatrix},\quad
\boldsymbol{\omega}=\begin{bmatrix}\omega_1\\\omega_2\\\omega_3\\\omega_4\end{bmatrix},
\end{equation}
where $\boldsymbol{\xi}$ [m] denotes the position of the centre of mass in the global coordinate system, $\boldsymbol{\eta}$ [rad] is the euler-angles in the body coordinate system and $\omega_i$ [rad/s] is the angular speed of the rotor $i$. For future reference, the basis vectors in the cartesian coordinate system are written $\hat{\mathbf{x}}$, and the subindexing $\mathbf{\cdot}_B$ refers to the vector of matrix defined in the body coordinate system. The translation from the global- to the body coordinate system is done by the orthogonal rotation matrix
\begin{equation}
\mathbf{R} = 
\begin{bmatrix}
\cos(\psi)\cos(\phi) & \cos(\psi)\sin(\theta)\sin(\phi)- \sin(\psi)\cos(\phi) & \cos(\psi)\sin(\theta)\cos(\phi)+ \sin(\psi)\sin(\phi)\\
\sin(\psi)\cos(\phi) & \sin(\psi)\sin(\theta)\sin(\phi) + \cos(\psi)\cos(\phi) & \sin(\psi)\sin(\theta)\cos(\phi) - \cos(\psi)\sin(\phi)\\
 - \sin(\theta) & \cos(\theta)\sin(\phi) &  \cos(\theta)\cos(\phi)
\end{bmatrix}
\end{equation}
such that a vector defined in the body system $\mathbf{v}_B$ can be translated to the global coordinate by the mapping
\begin{equation}
\mathbf{v} = \mathbf{R}^{-1}\mathbf{v}_B = \mathbf{R}^{T}\mathbf{v}_B.
\end{equation}

The force generated by a rotor is assumed to be proportional to the rotor speed squared,
\begin{equation}
f_i = k\omega_i^2
\end{equation}
with some constant $k$ and the torque around each motor axis can be written
\begin{equation}
\tau_{M_i}\ = b\omega_i^2+I_M\dot{\omega_i}
\end{equation}
where $b$ is a drag constant and $I_M$ is the rotor inertia. By the symmetry of the system, the thrust and torque vectors in the body coordinate system can then be wtitten
\begin{equation}\label{eq:torque}
\mathbf{T}_{B} =
T \hat{\mathbf{z}}_B= 
\begin{bmatrix}
0\\
0\\
 k\sum\limits_{i = 1}^4\omega_i^2
\end{bmatrix}
, \qquad
\boldsymbol{\tau}_B = 
\begin{bmatrix}
\tau_{\phi}\\
\tau_{\theta}\\
\tau_{\psi}\\
\end{bmatrix}
=
\begin{bmatrix}
kl(-\omega_2^2 + \omega_4^2)\\
kl(-\omega_1^2 + \omega_3^2)\\
\sum\limits_{i = 1}^4\tau_{M_i}\\
\end{bmatrix}
\end{equation}
Assuming that the quadcopter experiences air resistance, which increases with $\dot{\boldsymbol{\xi}}$, we simply define a matrix
\begin{equation}
\mathbf{D} =
\begin{bmatrix} D_{11} & 0 & 0\\ 0 & D_{22} & 0\\ 0 & 0 & D_{33}\\\end{bmatrix}
\end{equation}
where the coefficients remain to be estimated. With the above definitions, the non-linear dynamics of the quadcopter can then be derived from the Newton-Euler equations as
\begin{equation}
\begin{cases}
 m\ddot{\boldsymbol{\xi}} = m\mathbf{G} + \mathbf{T}_{B}-\mathbf{D}\dot{\boldsymbol{\xi}}\\
\ddot{\boldsymbol{\eta}}=\mathbf{J}^{-1}(\boldsymbol{\eta})(\boldsymbol{\tau}_B-\mathbf{C}(\boldsymbol{\eta},\dot{\boldsymbol{\eta}})\dot{\boldsymbol{\eta}}),
\end{cases}
\end{equation}
A brief description of $\mathbf{J}$ and $\mathbf{C}$ matrices can be found in \textbf{Section~\ref{sec:appendix}}, but the interested reader is referred to ~\cite{luukkonen2011modelling} for a more thorough derivation of the Newton-Lagrange equations. In the work of Lukkonen, this system was simulated in continuous time, and here we will take an alternate approach in order to implement the dynamics as a discrete time ROS node in Python.

\subsection{Non-linear model}
By defining the states and control signals as

\begin{equation}
\mathbf{x} = 
\begin{bmatrix}
\boldsymbol{\xi} \\ 
\dot{\boldsymbol{\xi}} \\ 
\boldsymbol{\eta} \\ 
\dot{\boldsymbol{\eta}}
\end{bmatrix}
\in\mathbb{R}^{12\times 1}, \quad\text{and}\quad
\mathbf{u} = 
\begin{bmatrix}
T\\
\tau_{\phi}\\
\tau_{\theta}\\
\tau_{\psi}
\end{bmatrix}\in\mathbb{R}^{4\times 1}
\end{equation}
respectively, the full non-linear system can then be written
\begin{flalign}\label{eq:contsys}
\begin{split}
\dot{\mathbf{x}}(t) =&\mathbf{A}^c\mathbf{x}(t)+\mathbf{B}^c\mathbf{u}(t)+\mathbf{G}^c\\
\mathbf{y}(t) =& \mathbf{C}^c\mathbf{x}(t)
\end{split}
\end{flalign}
with 
\begin{equation}
\mathbf{A}^c=\begin{bmatrix}
\mathbf{0} & \mathbb{I}_{3\times 3} & \mathbf{0} & \mathbf{0} \\
\mathbf{0} & -\frac{1}{m}\mathbf{D} & \mathbf{0} & \mathbf{0} \\
\mathbf{0} & \mathbf{0} & \mathbf{0} &\mathbb{I}_{3\times 3} & \\
\mathbf{0} & \mathbf{0} & \mathbf{0} &-\mathbf{J}^{-1}(\boldsymbol{\eta})\mathbf{C}(\boldsymbol{\eta},\dot{\boldsymbol{\eta}}) 
\end{bmatrix},
\mathbf{B}^c=\begin{bmatrix}
\mathbf{0} &\mathbf{0}\\
\frac{1}{m}\mathbf{R}\hat{\mathbf{z}} & \mathbf{0}\\
\mathbf{0} &\mathbf{0}\\
\mathbf{0} & \mathbf{J}(\boldsymbol{\eta})^{-1}\\
\end{bmatrix},
\mathbf{G}^c\begin{bmatrix}
\mathbf{0}\\
\mathbf{G}\\
\mathbf{0}\\
\mathbf{0}\\
\end{bmatrix},
\mathbf{C}^c=\begin{bmatrix}
 \mathbf{0}_{7\times 2} & \mathbb{I}_{7\times7} & \mathbf{0}_{7\times 2}
\end{bmatrix}
\end{equation}
The $\mathbf{C}^c$ matrix was chosen to reflect the available sensory information. The height $z$ is measured by a pressure sensor, the angles $\boldsymbol{\eta}$ are retrieved from a gyroscope aboard the quadcopter and the velocities $\dot{\boldsymbol{\xi}}$ are integrated from readings of the combined sensory feedback from the accelerometer and magnetometer.

In order to simulate the dynamics, the continuous time system~\eqref{eq:contsys} was implemented in Simulink (see \texttt{quadcopter\_model.m}, \textbf{Section~\ref{sec:appendix}}), and validated by comparison to the results in~\cite{luukkonen2011modelling}. The discrete time system was then computed using zero-order hold at a time step $h$, with the discrete state space representation
\begin{flalign}
x(t_k + h) =& \mathbf{A}^dx(t_k) + \mathbf{B}^d\mathbf{u}(t_k) + \mathbf{G}^d\\
y(t_k) =& \mathbf{C}^dx(t_k)\\
\end{flalign}
where
\begin{equation}
\mathbf{A}^d =e^{\mathbf{A}^ch},\qquad
\mathbf{B}^d =\int_0^he^{\mathbf{A}^ch} dsB^c,\qquad
\mathbf{G}^d =h\mathbf{G}^c,\qquad
\mathbf{C}^d =\mathbf{C}^c.
\end{equation}
As the final implementation of the control system was done in ROS based in Python and C++, a script was written do simulate the system using only the scipy and numpy modules (see simulate\_system.py, \textbf{Section~\ref{sec:appendix}}). The result  (see Figure~\ref{fig:}).

\subsection{Attitude PD control dynamics}
The system is inherently unstable, as the only truly stable position is at $\dot{\boldsymbol\xi}=\boldsymbol\eta=\dot{\boldsymbol\eta}=0$. In the derivation of the control schemes, it might be interesting to develop controllers not only for the unstable non-linear systems~\eqref{eq:contsys}, but also for a system which is stabilised with a attitude PD controller. Such a controller was derived in~\cite{luukkonen2011modelling}~\cite{dikmen2009attitude}, and can be summarised in the scheme
\begin{flalign}
\begin{split}
T=&(g + K_{D,z}(\dot{z}_{ref} - \dot{z})) + K_{P,z}(z_{ref} - z))\frac{m}{\cos(\phi)\cos(\theta)}\\
\tau_{\phi}=&(K_{D,\phi}(\dot{\phi}_{ref} - \dot{\phi})) + K_{P,\phi}(\phi_{ref} - \phi))I_{xx}\\
\tau_{\theta}=&(K_{D,\theta}(\dot{\theta}_{ref} - \dot{\theta})) + K_{P,\theta}(\theta_{ref} - \theta))I_{yy}\\
\tau_{\psi}=&(K_{D,\psi}(\dot{\psi}_{ref} - \dot{\psi})) + K_{P,\psi}(\psi_{ref} - \psi))I_{zz}
\end{split}
\end{flalign}
In using this controller, setting all references to 0 results in a stable hovering system. By defining the control error as $e_z = z_{ref} - z$, the controller can be written
\begin{flalign}
\begin{split}
T=&\hat{g} + \alpha_{D,\dot{z}}\dot{e}_{z} +  \alpha_{P,{z}}e_{z}\\
\tau_{\phi}=& \alpha_{D,\dot{\phi}}\dot{e}_{\phi} +  \alpha_{P,{\phi}}e_{\phi}\\
\tau_{\theta}=&\alpha_{D,\dot{\theta}}\dot{e}_{\theta} +  \alpha_{P,{\theta}}e_{\theta}\\
\tau_{\psi}=&\alpha_{D,\dot{\psi}}\dot{e}_{\psi} +  \alpha_{P,{\psi}}e_{\psi}\\
\end{split}
\end{flalign}
Including these dynamics in the system, and linearising around the stable state $\eta = \dot{\eta}= [0,0,0]^T$ we get the linearised system matrices

\subsection{Rotor-loop dynamics}

TODO: Find transfer function from motor current to rotor speed on the form
\begin{equation}
H_{I\rightarrow \dot{\omega}}(s) \approx \frac{b_0}{s + a_0}
\end{equation}
The step response of the system is then
\begin{equation}
\frac{b_0}{s + a_0} \frac{1}{s} = \frac{b_0}{a_0}\Big(\frac{1}{s} - \frac{1}{s + a_0}\Big) \overset{\mathcal{L}_t}{\longrightarrow}
\frac{b_0}{a_0}(e^{-t} - e^{-a_0t})
\end{equation}
and can easily be identified by means of system identification. A simple test would be to measure the response of two unit steps in succession to determine both coefficients. The motor is incredibly responsive, going from ${\boldsymbol\omega} = 0$ to ${\boldsymbol\omega}\approx 2.5\cdot 10^4$ in $< 180$ ms. (see https://www.bitcraze.io/2015/02/measuring-propeller-rpm-part-3/). We have access to RPM measurements and can therefore construct a very fast PI or PID loop for each motor to keep $\boldsymbol\omega^2$ at a desired value. In this section, we could advance such a controller and show that it is indeed viable and very responsive. With this result in mind, it could be an idea to investigate methods of control when using $\boldsymbol\omega^2$, in which case the derived dynamics are the same except for the $\mathbf{B}^c$ matrix, which the must include the mapping of $\boldsymbol\omega^2$ to thrust and torques,
\begin{equation}
\begin{bmatrix}
T\\
\tau_{\phi}\\
\tau_{\theta}\\
\tau_{\psi}
\end{bmatrix}
=
\mathbf{M}_{\omega}\boldsymbol\omega^2
\quad\text{where}\quad
\mathbf{M}_{\omega} = 
\begin{bmatrix}
    k&    k&   k&   k\\
    0& -kl&   0& kl\\
 -kl&    0& kl&  0\\
   -b&    b&  -b&   b\\
\end{bmatrix}
\quad\text{and}\quad
\mathbf{M}^{-1}_{\omega} = 
\begin{bmatrix}
    \frac{1}{4k}& 0 & -\frac{1}{2kl} &  \frac{1}{4b}\\
    \frac{1}{4k}& -\frac{1}{2kl} & 0 & -\frac{1}{4b}\\
    \frac{1}{4k}& 0 &  \frac{1}{2kl} &  \frac{1}{4b}\\
    \frac{1}{4k}&  \frac{1}{2kl} & 0 & -\frac{1}{4b}\\
\end{bmatrix}
\end{equation}
as derived from equation~\eqref{eq:torque}. The updated continuous system, with $\mathbf{u} = \boldsymbol\omega^2$ is then
\begin{flalign}\label{eq:contsys2}
\begin{split}
\dot{\mathbf{x}}(t) =&\mathbf{A}^c\mathbf{x}(t)+\mathbf{B}^c\mathbf{M}_{\omega}\mathbf{u}(t)+\mathbf{G}^c\\
\mathbf{y}(t) =& \mathbf{C}^c\mathbf{x}(t)
\end{split}
\end{flalign}

\section{MPC control}
Different implementation paths
\begin{enumerate}
\item Include rotor control loops in the system matrix before linearising, thus giving a better model of the system for the MPC controller at the cost of increasing the dimension of $\mathbf{A}^c$ from $12\times 12$ to $21\times 21$ (if using PID control for the rotors). as the rotors are very responsive, this might not be necessary, and we may get away with simply using $\boldsymbol\omega^2$ as input signal and assume that the real value is equal to the reference value at all times. However, this will have to be examined in simulations.
\item Decide using simulations is the stabilizing PD controller should be used in MPC or if the $\boldsymbol\omega^2$ control signals should be controlled directly.
\end{enumerate}
In total, we could test all four combinations of with/without omega-loop dynamics and with/without stabilizing PD.
\subsubsection*{TODO}
\begin{enumerate}
\item \sout{Create simplified linearised system ss-model for use in MPC} (see eg.~\cite{Bouffard:EECS-2012-241}).
\item \sout{Validate by comparison to the results in}~\cite{Bouffard:EECS-2012-241}.
\item \sout{Set up QP-MPC controller with Simulink MPC-library} (see eg.~\cite{Bouffard:EECS-2012-241}).
\item \sout{Validate by comparison to the results in}~\cite{Bouffard:EECS-2012-241}.
\item Set up QP-MPC controller with CVXGEN m-code (see eg.~\cite{Bouffard:EECS-2012-241}~\cite{mattingley2012cvxgen}).
\item Validate by comparison to the results in Simulink.
\item System identification.
\item Simulate system with proper parameters.
\item Compare the four different implementations based on speed and stability.
\end{enumerate}
\section{$\mathcal{L}_1$-control}
The $\mathbf{\Gamma}$-projection operator for two vectors $\theta,y\in\mathbb{R}^k$ is defined as
\begin{equation}
\text{Proj}_{\mathbf{\Gamma}}(\theta,y,f) =
\begin{cases}
\mathbf{\Gamma} y - \mathbf{\Gamma}\dfrac{\nabla f(\theta)(\nabla f(\theta))^T}{||\nabla f(\theta)||_2}\mathbf{\Gamma} yf(\theta)\qquad
\text{if}\;\;f(\theta)>0\;\;\text{and}\;\;y^T\nabla f(\theta)>0\\
\mathbf{\Gamma} y\qquad\qquad\qquad\qquad\qquad\qquad\quad\quad\text{otherwise}.
\end{cases}
\end{equation}
where $\mathbf{\Gamma} = \mathbb{I}_{k\times k}\Gamma$ for some scalar $\Gamma > 0$ (typically $\Gamma\approx 10^5$) and $f(\theta)$ is a convex function~\cite{lavretsky2011projection}. By solving the Lyapunov equation
\begin{equation}
\mathbf{A}_m\mathbf{X}+ \mathbf{X}\mathbf{A}_m^T+ \mathbf{Q} = 0,
\end{equation}
for $\mathbf{P}=\mathbf{P}^T$, with some arbitrary $\mathbf{Q}>0$, the feedback controller
\begin{equation}
\begin{cases}
u(t)=\hat{\theta}^Tx(t)+k_gr(t)\\
\dot{\hat{\theta}}(t) = \text{Proj}_{\mathbf{\Gamma}}(\hat{\theta}^T(t),x(t)\tilde{x}^T(t)\mathbf{X}b)
\end{cases}
\end{equation}
can be constructed, where $\tilde{x} = \hat{x} - x$ is the state estimation error, $k_g$ is a gain and $r(t)$ is the reference signal. By designing the companion system
\begin{equation}
\begin{cases}
\dot{x}(t) = \mathbf{A}_m\hat{x}(t) + b(u(t)-\hat{\theta}^T(t)x(t))\\
y(t) = c^T\hat{x}(t)
\end{cases}
\end{equation}
it can be shown (by Theorem 2~\cite{cao2006design}) that the state estimation error,
\begin{equation}
\lim_{t\rightarrow\infty}\tilde{x} = 0.
\end{equation}
By a corollary of the theorem, choosing
\begin{equation}
k_g =-\frac{1}{c^T\mathbf{A}_m^{-1}b} \Rightarrow \lim_{t\rightarrow\infty}y(t) = r
\end{equation}
if $r \equiv$ constant.
\begin{enumerate}
\subsubsection*{TODO}
\item \sout{Define general control structure.}
\item Create Simulink projection operator (see eg.~\cite{L1control})
\item Validate projection operator against benchmark Simulink models (eg. ~\cite{cao2006design}).
\item Define robustness metrics (see eg.~\cite{L1control}~\cite{huynh20141})
\item Create script for computing the $\mathcal{L}_1$-gain (see eg.~\cite{L1control}).
\item Validate script against benchmark Simulink models (eg. ~\cite{cao2006design}).
\item Simulate control.
\end{enumerate}

\section{General TODOs}
\begin{enumerate}
\item Found that one of the copters were broken - sent to Bitcraze for repairs, expected to be done in early march.
\item Tried installing IRIS in Ubuntu but ran into issues using the PODS "make" command required to get everything up and running. TODO: contact Claes or Anders to get help in finding someone experienced with PODS.
\end{enumerate}

\newpage\bibliography{bibliography}{}
\bibliographystyle{IEEEtran}

\section{Appendix}\label{sec:appendix}
\end{document}