#!/usr/bin/env python

from std_msgs.msg import String, Float64
from crazy_ros.msg import NumpyArrayFloat64 # Can handle messages of type np.array, list and tuple
import numpy as np
from math import sin, pi, sqrt
import rospy
import os
import sys
from json import dumps, load
import time

class KinectLink(object):
    ##########################################################################
    # Node for configuring and linking the kinect 1 to the quadcopter driver #
    ##########################################################################
    def __init__(self):
        # Sets up subscribers
        self.data_sub = rospy.Subscriber('Kinect_data', String, self.handle_kinect_data)
        self.status_sub = rospy.Subscriber('Kinect_status', String, self.handle_status_data)

        # Sets up publisher
        self.status_pub = rospy.Publisher('system_status', String, queue_size = 10)
        self.data_pub = rospy.Publisher('kinect_position_measurement', String, queue_size = 10)

        self.mode = 'Run'
        self.angle = None

        # Used in configure bckground
        self.background = None
        self.framecount = 0

        # Used in configure depth
        self.currentImage = None

    def handle_kinect_data(self, msg):
        # Callback for the Image data generated by the kinect. Treats the data
        # differently depending on the operating mode. The modes are:
        #
        #    * ConfigureBackround - Takes 100 consecutive image and stores the
        #        mean value as a reference for other running modes and image
        #        processing.
        #    * ConfigureDepth - Stores each received image in the
        #        self.currentImage attribute, where it is then accessed by the
        #        configure_* functions 
        #    * ConfigureAngle configures the angle of the kinect based on the
        #        assumption that the kinect is facing a wall, does nothing
        #        presentl.
        #    * Run - prints the current position of the quadcopter to the
        #        /kinect_position_measurement topic

        if self.mode == 'ConfigureBackround':
            # Takes a total of 100 backround samples and stores the mean
            if self.framecount < 100:
                self.background = self.background + msg.data
                self.framecount += 1
            else:
                self.background = self.background / float(self.framecount)
                self.mode == 'Run'

        elif self.mode == 'ConfigureDepth':
            self.currentImage = msg.data

        elif self.mode == 'ConfigureAngle':
            self.currentImage = msg.data
        else:
            self.currentImage = msg.data

    def handle_status_data(self, msg):
        # Callback for the status of the kinect.
        if msg.data == 'ConfigureBackround':
            self.mode = msg.data
            print msg.data
        elif msg.data == 'ConfigureDepth':
            self.configure_depth()
            print msg.data
        elif msg.data == 'ConfigureAngle':
            self.mode = msg.data
            print msg.data
        else:
            print 'Unsupported kinecto mode %s, no action taken' % (msg.data)

    def configure_depth(self):
        maxSamples = 5
        nSamples = 0

        while nSamples < maxSamples:
            command = raw_input('Enter distance from camera [m]: ')
            nSamples += 1
            print command
            # TODO handle data

        print 'Configuration complete!'
        # Allows the master node to continue operation
        self.status_pub.publish('True')

    def __str__(self):
        return 'Kinect Link'

def main():
    rospy.init_node('KinectLink')
    kL = KinectLink()
    rospy.spin()

if __name__ == '__main__':
    main()
