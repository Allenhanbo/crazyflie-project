#!/usr/bin/env python

from std_msgs.msg import String, Float64
import ros_numpy
import numpy as np
from stereo_msgs.msg import DisparityImage
from rospy.numpy_msg import numpy_msg
import rospy
class KinectLink(object):
    ##########################################################################
    # Node for configuring and linking the kinect 1 to the quadcopter driver #
    ##########################################################################
    def __init__(self):
        # Sets up subscribers
        self.data_sub = rospy.Subscriber('/camera/depth/disparity', numpy_msg(DisparityImage), self.handle_kinect_data)
        self.status_sub = rospy.Subscriber('Kinect_status', String, self.handle_status_data)

        # Sets up publisher
        self.status_pub = rospy.Publisher('system_status', String, queue_size = 10)
        self.data_pub = rospy.Publisher('kinect_position_measurement', String, queue_size = 10)

        self.mode = 'ConfigureBackground'
        self.angle = None

        # Used in configure bckground
        self.background = np.zeros((480, 640))
        self.framecount = 0

        # Used in configure depth
        self.currentImage = None

    def handle_kinect_data(self, msg):
        # Callback for the Image data generated by the kinect. Treats the data
        # differently depending on the operating mode. The modes are:
        #
        #    * ConfigureBackround - Takes 100 consecutive image and stores the
        #        mean value as a reference for other running modes and image
        #        processing.
        #    * ConfigureDepth - Stores each received image in the
        #        self.currentImage attribute, where it is then accessed by the
        #        configure_* functions
        #    * ConfigureAngle configures the angle of the kinect based on the
        #        assumption that the kinect is facing a wall, does nothing
        #        presentl.
        #    * Run - prints the current position of the quadcopter to the
        #        /kinect_position_measurement topic
        image = msg.image
        np_image = ros_numpy.numpify(image)
        image = np_image - self.background
        #max_ind = np.argmax(np_image)
        #i,j = np.unravel_index(np_image.argmax(), np_image.shape)

        #print i, j, np.max(np_image)

        if self.mode == 'ConfigureBackground':
            # Takes a total of 100 backround samples and stores the mean
            if self.framecount < 100:
                self.background = self.background + np_image
                self.framecount += 1
            else:
                self.background = self.background / float(self.framecount)
                self.mode = 'Run'

        elif self.mode == 'ConfigureDepth':
            self.currentImage = image

        elif self.mode == 'ConfigureAngle':
            self.currentImage = image
        else:
            self.currentImage = image

            i,j = np.unravel_index(image.argmax(), image.shape)
            print i, j, image[i, j], np_image[i, j], self.background[i, j]
            print type(image)
            #i,j = np.unravel_index(np_image.argmax(), np_image.shape)
            #print i, j, np.max(np_image)
            #i,j = np.unravel_index(self.background.argmax(), self.background.shape)
            #print i, j, np.max(self.background)
            print '-'*10

    def handle_status_data(self, msg):
        # Callback for the status of the kinect.
        if msg.data == 'ConfigureBackround':
            self.mode = msg.data
            print msg.data
        elif msg.data == 'ConfigureDepth':
            self.configure_depth()
            print msg.data
        elif msg.data == 'ConfigureAngle':
            self.mode = msg.data
            print msg.data
        else:
            print 'Unsupported kinecto mode %s, no action taken' % (msg.data)

    def configure_depth(self):
        maxSamples = 5
        nSamples = 0

        while nSamples < maxSamples:
            command = raw_input('Enter distance from camera [m]: ')
            nSamples += 1
            print command
            # TODO handle data

        print 'Configuration complete!'
        # Allows the master node to continue operation
        self.status_pub.publish('True')

    def __str__(self):
        return 'Kinect Link'

def main():
    rospy.init_node('KinectLink')
    kL = KinectLink()
    rospy.spin()

if __name__ == '__main__':
    main()
